1、[科普文：常见垃圾回收算法与 JS GC 原理](https://mp.weixin.qq.com/s/KZsgQxlrsfYMvJejbZqGHw)

概要：
- C/C++ 就是使用 「手动回收」 策略，而 JavaScript/Java/Python 等使用自动回收策略，产生的垃圾数据由 「垃圾回收器」 主动释放。
- 经典自动垃圾回收算法，有五种：标记-清除法、复制算法、引用计数（无法解决循环引用问题）、标记-压缩算法、代际假设和分代收集。
- JavaScript 垃圾回收： JavaScript 的原始数据类型存在栈中，引用数据类型存在堆中，所以讨论 JavaScript 的垃圾回收即讨论其栈中数据的回收以及堆中数据的回收。
    - 栈中垃圾回收：ESP(Extended Stack Pointer): 扩展栈指针寄存器，用于存放函数栈顶指针。JavaScript 引擎是通过下移 ESP 来完成栈的垃圾回收的。
    - 堆中垃圾回收：JavaScript 引擎（V8 的垃圾回收策略）将堆空间分为 「新生代(young-space)」 和 「老生代(old-space)」。为了避免垃圾回收影响应用的性能，V8 将标记的过程拆分成多个子标记，让垃圾回收标记和应用逻辑交替执行，避免脚本任务等待较长时间。

补充：JS 中的 标记清除算法，来解决引用计数无法克服的循环调用问题：来自 [Js的GC机制](https://blog.csdn.net/qq_40413670/article/details/106232321)

对于引用计数垃圾回收算法，把对象是否不再需要简化定义为该对象是否可以获得，该算法设置一个叫做根root的对象（在Javascript里根是全局对象），垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象，以此不断向下查找。从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象，这样便解决了循环引用的问题。标记结束后，标记-整理方法会将活着的对象向内存的一端移动，最后清理掉边界的内存。

所有现代浏览器都使用了标记清除垃圾回收算法，所有对JavaScript垃圾回收算法的改进都是基于标记清除算法的改进。

2、[JS探索-GC垃圾回收](https://zhuanlan.zhihu.com/p/103110917)

（1）NodeJs V8 中的垃圾回收机制

V8 堆的整体大小等于新生代所用内存空间加上老生代的内存空间，而只能在启动时指定，意味着运行时无法自动扩充，如果超过了极限值，就会引起进程出错。

在分代的基础上，新生代的对象主要通过 Scavenge 算法进行垃圾回收，在 Scavenge 具体实现中，主要采用了一种复制的方式的方法—— Cheney 算法。
Cheney 算法将堆内存一分为二，一个处于使用状态的空间叫 From 空间，一个处于闲置状态的空间称为 To 空间。分配对象时，先是在 From 空间中进行分配。
当开始进行垃圾回收时，会检查 From 空间中的存活对象，将其复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生对换。

对于老生代中的对象，主要采用标记-清除和标记-整理算法。

（2）内存泄漏的常见场景

缓存：JS 开发者喜欢用对象的键值对来缓存函数的计算结果，但是缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功。

作用域未释放（闭包）：闭包可以维持函数内部变量驻留内存，使其得不到释放。

全局变量：声明过多的全局变量，会导致变量常驻内存，要直到进程结束才能够释放内存。

无效的 DOM 引用：比如 document.getElementById('button')，但这个元素已经被移除。

定时器未清除：比如 setTimeout, setInterval

事件监听：比如 window.addEventListener("scroll", ...)


