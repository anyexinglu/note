# 浏览器

## 浏览器有哪些进程

Chrome 浏览器使用的是多进程多线程模式，因为现在的网页复杂性非常高。如果整个浏览器是单进程的，有可能某个 page 界面的抛错就会导致整个浏览器的 crash。同时多个界面互相可以访问相同的内存和相同的执行环境，安全性也是一个大的问题，所以浏览器需要采用多进程模式。

浏览器的进程大概分为以下这几种：

（1）浏览器主进程(Browser进程)：控制 chrome 的地址栏，书签栏，返回和前进按钮，同时还有浏览器的不可见部分，例如网络请求和文件访问。

（2）第三方插件进程：每种插件一个进程，插件运行时才会创建。

（3）浏览器渲染进程（浏览器内核，内部是多线程的）：负责界面渲染，脚本执行，事件处理等。

（4）GPU 进程：最多一个，用于 3D 绘制。

 ![](https://img2018.cnblogs.com/blog/998371/201906/998371-20190629174055243-1647511949.png)

## 浏览器有哪些线程

浏览器的渲染进程是多线程的。js 是阻塞单线程的。浏览器包含有以下线程：

（1）GUI 渲染线程
负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。
注意，GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

（2）JS 引擎线程
也称为 JS 内核，负责处理 Javascript 脚本程序。（例如V8引擎）
JS 引擎线程负责解析 Javascript 脚本，运行代码。
JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。
同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

（3）事件触发线程
归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）
当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中
当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）

（4）定时触发器线程
传说中的 setInterval 与 setTimeout 所在线程
浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确）
因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
注意，W3C 在HTML标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

（5）异步 http 请求线程
在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。
将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

## 浏览器同源策略和跨域方案

浏览器同源策略：同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。
限制以下行为：
- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 和 Js对象无法获得
- AJAX 请求不能发送

有三个标签是允许跨域加载资源，iconfont 字体文件(eot|otf|ttf|woff|svg)则不允许：
```html
<img src=XXX>
<link href=XXX>
<script src=XXX>
```

解决方案：
- 通过 jsonp 跨域，如定义好 callback 然后添加 script 标签，设置 `script.src = 'http://www.domain2.com:8080/login?user=admin&callback=cb'`。服务端返回数据时会将这个callback 参数作为函数名来包裹住 JSON 数据。
- document.domain + iframe 跨域。
- location.hash + iframe，通过 url hash 跨 iframe 通信。
- window.name + iframe 跨域：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。
- postMessage：一般用于解决以下问题
  - 页面和其打开的新窗口的数据传递
  - 多窗口之间消息传递
  - 页面与嵌套的 iframe 消息传递
  - 上面三个场景的跨域数据传递
- 跨域资源共享（CORS）：主流的跨域解决方案。服务端设置 Access-Control-Allow-Origin 即可
- nginx 代理跨域和 nodejs 中间件代理跨域。

## 在地址栏里输入一个地址回车会发生哪些事情

（1）解析 URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

（2）缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

（3）DNS 解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

（4）获取 MAC 地址：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 ARP（地址解析协议）获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

（5）TCP 三次握手：首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号（同步位 SYN 置为 1，随机序号 seq = x），服务端接收到请求后向客户端发送一个 SYN ACK 报文段和一个随机序号（确认位 ACK = 1，确认号 ack = x + 1，同步位 SYN = 1，随机序号 seq = y）。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段（确认位 ACK = 1，确认号 ack = y + 1，seq = x + 1），服务器端接收到确认后连接建立。

（6）HTTPS 握手：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

（7）返回数据：当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

（8）页面渲染：浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

（9）TCP 四次挥手：最后一步是 TCP 断开连接的四次挥手过程。
- C -> S：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求，进入 FIN_WAIT（FIN = 1，随机序号 seq = m）。
- S -> C：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态（确认位置 ACK = 1，ack = m + 1），此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端
- S -> C：服务端数据发送完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态（FIN = 1，随机序号 seq = n）。
- C -> S：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态（确认位置 ACK = 1，ack = n + 1）。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

![](./tcp_bye.webp)

## 性能监控和优化

TODO

## 「Event Loop」浏览器环境下 js 引擎的事件循环机制

Event Loop 即事件循环，是指浏览器或 Node 的一种解决 JS 单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。

### （1）执行栈与事件队列

事件循环的设计核心是「异步任务」：
- 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
- 异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

名词解释：
- Tick：Every time the event loop takes a full trip, we call it a tick.

### （2）微任务和宏任务

> 理解微任务宏任务：[jsv9000](https://www.jsv9000.app/?continueFlag=c5873e6868c78e95e688cf10f05ff5fb)

主线程执行栈执行完毕时会立刻先处理所有「微任务队列中的事件」，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。

以下事件属于宏任务：
- （I/O、UI渲染、requestAnimationFrame，都是先于微任务执行）
- setInterval()
- setTimeout()
- ...（Node 环境下还有 setImmediate）

以下事件属于微任务：
- （Node 环境下有 process.nextTick()，在微任务队列最初执行）
- queueMicrotask()
- new Promise()
- new MutationObserver()
- Object.observe()

所以：
```js
setTimeout(function () {
    console.log(1);
});

new Promise(function(resolve,reject){
    console.log(2)
    resolve(3)
}).then(function(val){
    console.log(val);
})
```

执行结果是：
```js
2
3
1
```

需要注意的是，setTimeout() 只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout() 指定的时间执行。

## 「Event Loop」node 环境下的事件循环机制

Node.js 也是单线程的 Event Loop，但是它的运行机制不同于浏览器环境。Node.js 的运行机制如下：

- V8 引擎解析 JavaScript 脚本。
- 解析后的代码，调用 Node API。
- libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。
- V8 引擎再将结果返回给用户。

### process.nextTick()

> [Nodejs nexttick](https://nodejs.dev/learn/understanding-process-nexttick)

Every time the event loop takes a full trip, we call it a tick.

When we pass a function to process.nextTick(), we instruct the engine to invoke this function at the end of the current operation, before the next event loop tick starts:

```js
process.nextTick(() => {
  // do something
});
```

当事件循环准备进入下一个阶段之前，会先检查 nextTick queue 中是否有任务，如果有，那么会先清空这个队列，再进入下一个 Event Loop。与执行 poll queue 中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，递归调用 process.nextTick() 方法会导致 node 进入一个死循环。直到内存泄漏。
### setTimeout() 和 setImmediate()

setImmediate() 实际上却是在一个固定的 poll 阶段之后才会执行回调。
```js
setTimeout(() => {
    console.log('timeout');
}, 0);

setImmediate(() => {
    console.log('immediate');
});
```
连 Node 的开发者都无法准确的判断这两者的顺序谁前谁后，这取决于这段代码的运行环境。 
但在 I/O 事件的回调中，setImmediate 方法的回调永远先于 setTimeout 的回调执行。

### 综合题

```js
console.log(1)
new Promise(function(resolve){
    console.log(2);
    resolve(3);
    console.log(4);
}).then(res => {
    console.log(res)
    process.nextTick(() => {
        console.log('in nextTick')
    });
    Promise.resolve(5).then(res => {
        console.log(res)
    })
    setImmediate(() => {
        console.log('in setImmediate');
    });
})
setTimeout(() => {
    console.log('in setTimeout')
}, 0)
console.log(6)
 
```
答案：
```js
1
2
4
6
3
5
in nextTick
in setTimeout
in setImmediate
// （理论上开始 setTimeout 和 setImmediate 顺序不稳定，但我 Node v16.14.0 测下来多次都是如此 ）
```

## JIT

> [JavaScript 编译 - JIT](https://zhuanlan.zhihu.com/p/99395691)

JavaScript 刚出现的时候，是一个典型的解释型语言，因此运行速度极慢，后来浏览器引入了 JIT compiler，大幅提高了 JavaScript 的运行速度。


JIT 提速的关键：

- 记录一段代码被执行的次数（解释器 Interpreter）：某一行代码被执行了几次，这行代码会被打上 Warm 的标签；当某一行代码被执行了很多次，这行代码会被打上 Hot 的标签。
- Warm 的代码编译后索引存储（Baseline compiler）：被打上 Warm 标签的代码会被传给 Baseline Compiler 编译且储存，同时按照行数 (Line number) 和变量类型 (Variable type) 被索引，避免重复编译。
- Hot 的代码根据概率提前对参数类型做出合理假设（Optimizing compiler）：被打上 Hot 标签的代码会被传给 Optimizing compiler，用概率模型对参数类型做一些合理的 ”假设 (Assumptions)“。

与之对应的是先编译再执行：AOT（Ahead of Time），JavaScriptCore 目前不支持 AOT。

# 计算机网络

## 网络七层模型

七层模型，也称为 OSI（Open System Interconnection）参考模型：

![](./network_7_layer.png)

1、应用层：为操作系统或网络应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。常见 Telnet、HTTP/HTTPS、FTP、DNS 等。

2、表示层：提供数据格式转化服务，格式化也因所使用网络的类型不同而不同。常见加密解密（安全，如 URL/口令加密）、图片编码和解码、数据的压缩和解压。SSL（安全套接字层） 就在这层，SSL 在 1999 年被 IETF(互联网工程组)更名为 TLS（传输安全层）。

3、会话层：建立端连接，并提供访问验证和会话管理（建立、管理、终止会话）。常见服务器验证用户登录、断点续传。

4、传输层（数据段 Segment）：提供应用进程之间的逻辑通信，定义传输数据的协议和端口号（WWW 端口 80 等），以及流控和差错校验。常见 TCP、UDP、进程、端口等。
- TCP：传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据。
- UDP：用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的。

5、网络层（分组数据包 Packet）：对子网之间的数据包进行路由选择，并分组转发数据。设备有路由器、多层交换机、防火墙等，协议有 IP（IPV4 IPV6）、ICMP、IGMP、ARP、RARP 等。网关在网络层以上实现网络互连，

6、数据链路层（帧 Frame）：负责在不可靠的物理介质上提供可靠的传输，包括建立逻辑连接、进行硬件地址寻址、数据的成帧、流量控制、差错校验、重发等功能。常见网卡、网桥、二层交换机。

7、物理层（网络硬件，二进制比特 Bit）：网络通信的数据传输介质，由电缆和设备共同组成，主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。常见中继器、集成器、网线等。

### 五层网络协议

应用层、传输层、网络层、数据链路层、物理层（没有表示层、会话层）。

### TCP/TP 四层协议

应用层、传输层、网络层、物理链路层。其中：
- 应用层：对应 OSI 中的应用层、表示层、会话层。
- 物理链路层：对应 OSI 中的数据链路层、物理层（也有叫网络接口层）。

## HTTPS 和 HTTP 的区别

HTTP 传递信息是以明文的形式发送内容，不安全，HTTPS 让 HTTP 运行安全的 SSL/TLS 协议上，即 HTTPS = HTTP + SSL/TLS，通过 SSL 证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。

SSL 协议位于 TCP/IP 协议与各种应用层协议之间，浏览器和服务器在使用 SSL 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持。

![](https://pics7.baidu.com/feed/e824b899a9014c08fb5b19cca770da007bf4f40f.png)

- 首先客户端通过 URL 访问服务器建立 SSL 连接
- 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
- 客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
- 服务器利用自己的私钥解密出会话密钥
- 服务器利用会话密钥加密与客户端之间的通信

区别：
- HTTP 协议的数据传输是明文的，是不安全的，HTTPS 使用了 SSL/TLS 协议进行了加密处理，相对更安全
- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP 是 80，HTTPS 是 443
- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
- HTTPS 需要 SSL，SSL 证书需要钱，功能越强大的证书费用越高。

## HTTP/2 和 HTTP/1.x 的区别

> 关键字：二进制帧、头部压缩（首部表 diff）、优先级设计、多路复用、并行交错发送、服务器推送。

1、二进制帧：HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。

2、头部压缩：HTTP/2 对首部采取了压缩策略，客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对。请求一发送了所有的头部字段，第二个请求则只需要发送差「异数据」，这样可以减少冗余数据，降低开销。

3、优先级设计：在 HTTP/2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级，数值越大优先级越低。

4、多路复用：同域名复用单个 TCP 而非多个连接，该连接承载任意数量双向数据流，不再受「单个域名 6-8 个 TCP 链接请求」的限制。降低成本提高效率。

5、并行交错发送，流标识组装：多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。

6、服务器推送：服务端可以在发送页面 HTML 时主动推送其它资源比如 JS 和 CSS，而不用等到浏览器解析到相应位置，发起请求再响应。服务器推送也需要遵守同源策略，而且浏览器可以通过发送 RST_STREAM 帧来拒收。

### 相关文章

- [一文读懂 HTTP/2 特性](https://zhuanlan.zhihu.com/p/26559480)
- [HTTP/2 简介](https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn)

## TCP 三次握手、四次挥手

（1）为什么需要三次握手才能建立连接？

第三次是客户端确认「服务端的确认」，如果只有两次握手，客户端没有回应，会浪费服务端的资源。

（2）如果握手时客户端发送的 SYN 丢失了或者其他原因导致 Server 无法处理，怎么处理？

在 TCP 的可靠传输中，如果 SYN 包在传输的过程中丢失，此时 Client 会触发重传机制，但是也不是无脑的一直重传过去，重传的次数是受限制的，可以通过 tcp_syn_retries 这个配置项来决定。如果此时 tcp_syn_retries 的配置为 3，表示重传三次，意味着当第一次发送SYN后，需要等待(1 +2 +4 +8)秒，如果还是没有响应，connect就会通过 ETIMEOUT 的错误返回。

![](./tcp_retry.webp)

（3）为什么连接的时候是三次握手，关闭的时候却是四次握手？

因为 当 Server 端收到客服端 FIN 报文时，很可能并不会立即关闭 SOCKET。所以只能先回复一个 ACK 报文，告诉 Client 端 “你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。

> 四次挥手的情景大致是这样的：
- 客户端主机 C 说：“我没有数据了，断开连接吧。 ”
- 服务器 S 说：“好，但是我还有数据（不断给 C 发送数据，此时 C 已经不能给 S 发送数据了，但是必须要就收 S 发来的数据）。”
- （当 S 给 C 发完数据后）S 说：“我发完了，断开连接吧。”
- C 说：“好，断开连接吧。”
