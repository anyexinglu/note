# JS 基础

## 手写 Object.create

将传入的对象作为原型

```js
function ObjectCreate(obj) {
    function F() {
    }
    F.prototype = boj
    return new F()
}
```

## 手写 instanceof
```js
function isInstanceof(a, B) {
    let proto = Object.getPrototypeOf(a)
    while(proto) {
        if (proto === B.prototype) {
            return true
        } else {
            proto = Object.getPrototypeOf(proto)
        }
    }
    return false
}
```

## 手写 new 操作符

先介绍下 new 的用法：
```js
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
const car1 = new Car('Eagle', 'Talon TSi', 1993);
console.log(car1.make);  // expected output: "Eagle"
```

new 操作符做的事情：
- 创建一个空对象
- 将对象的原型设置为函数的 prototype 对象
- 让函数的 this 指向这个对象，执行构造函数的代码
- 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，返回这个返回值

代码实现：
```js
function newOperator(self, ...args) {
    if (typeof self !== 'function') {
        return console.error('type error')
    }
    const obj = new Object();
    obj.__proto__ = self.prototype;

    const result = self.apply(obj, args)
    return result && (typeof result === 'object' || typeof result === 'function') ? result : obj
}
// 验证
// newOperator(构造函数，初始化参数) 如：
newOperator(Car, 'Eagle', 'Talon TSi', 1993);   // 获到 Car {make: 'Eagle', model: 'Talon TSi', year: 1993}
```

## 手写 getType 类型判断函数

```js
function getType(data) {
    if (data === null) {
        return 'null'
    }
    if (typeof data === 'object') {
        let type = Object.prototype.toString.call(data)
        return type.replaceAll(/(\[object |\])/g, '').toLowerCase()   // 如从 '[object Number]' 中提取到 'Number'
    }
    return typeof data
}

```

## 手写 call 方法

```js
let obj = {
  value: "vortesnail",
};
function fn() {
  console.log(this.value);
}
// 实现手写 call 方法
Function.prototype.myCall = function (context, ...args) {
  // 判断调用对象
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  // 首先获取参数
  let result = null;
  // 判断 context 是否传入，如果没有传就设置为 window
  context = context || window;
  // 将被调用的方法设置为 context 的属性，用 Symbol 的原因：防止与提供新的 this 值的属性重复
  let fn = Symbol('fn')
  // this 即为我们要调用的方法
  context[fn] = this
  // 执行要被调用的方法
  result = context[fn](...args)
  // 删除手动增加的属性方法
  delete context[fn]
  // 将执行结果返回
  return result;
}

fn.myCall(obj) // "vortesnail"
```

## 手写 apply 方法

```js
let obj = {
  value: "vortesnail",
};
function fn(args) {
  console.log(this.value, args);
}
// 实现手写 apply 方法
Function.prototype.myApply = function (context, args) {
  // 判断调用对象
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  // 首先获取参数
  let result = null;
  // 判断 context 是否传入，如果没有传就设置为 window
  context = context || window;
  // 将被调用的方法设置为 context 的属性，用 Symbol 的原因：防止与提供新的 this 值的属性重复
  let fn = Symbol('fn')
  // this 即为我们要调用的方法
  context[fn] = this
  // 执行要被调用的方法
  result = context[fn](...args)
  // 删除手动增加的属性方法
  delete context[fn]
  // 将执行结果返回
  return result;
}

fn.myApply(obj, [1]) // "vortesnail 1"
```

## 手写 bind 方法

```js
let obj = {
  value: "vortesnail",
};
function fn(...args) {
  console.log(this.value, ...args);
}
// 实现手写 apply 方法
Function.prototype.myBind = function (context, ...args1) {
  // 判断调用对象
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  let ctx = context || globalThis
  let self = this
  return function Fn(...args2) {
    let args = [...args1, ...args2]
    // this 是 Fn 的实例，说明是 new 出来的
    return self.apply(this instanceof Fn ? this : ctx, args)
  }
}
fn.myBind(obj, 1, 2)(3) // "vortesnail 1 2 3"
```

## 去重

预设 oldArr = [1,2,3,42,2,1]

1、Set 方法
```js
newArr = Array.from(new Set(oldArr))
```

2、hash 表方法
```js
function unique(arr) {
    let hash = new Map()
    return arr.reduce((final, cur) => {
        if (!hash.get(cur)) {
            hash.set(cur, 1)
            return final.concat(cur)
        }
        return final
    }, [])
}
// 验证
unique([1, 2, 3, 42, 2, 1])
// [1, 2, 3, 42]
```

## 实现 flat

```js
function flat(arr, dep) {
    if (dep <= 0) {
        return arr.slice()
    }
    return arr.reduce((final, cur) => {
        return final.concat(Array.isArray(cur) ? flat(cur, dep - 1) : cur)
    }, [])
}
// 验证
flat([1,[2,3,[4,5]]], 2)
// [1, 2, 3, 4, 5]
```

# TS

## 实现 Pick<T, K extends keyof T>
```ts
type Pick<T, K extends keyof T> = {
    [P in K]: T[P]
}
```

## 实现 Record<K extends keyof any, T>
```ts
type Record<K extends keyof any, T> = {
    [P in K]: T
}
```

## 实现 Required
```ts
type Required<T> = {
    [P in keyof T]-?: T[P]
}
```

## 实现 ReturnType
```ts
typeof ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any
```

# 算法

## 二叉树遍历

- 先(前)序遍历：根结点 ---> 左子树 ---> 右子树
- 中序遍历：左子树---> 根结点 ---> 右子树
- 后序遍历：左子树 ---> 右子树 ---> 根结点
- 层序遍历：每一层从左向右的方式进行遍历

## 打印指定奇数行的菱形

打印菱形的函数 printDiamond(lines)，比如 lines = 5 结果就是：
```
  *
 ***
*****
 ***
  *
```
代码：
```js
function printDiamond(lines) {
    if (lines % 2 === 0) {
        return console.error('打印菱形行数必须是奇数')
    }
    for(let i = 1; i <= lines; i++) {
        const mid = (lines + 1) / 2
        const sideEmptyCount = Math.abs(mid  - i)
        const repeatTime = lines - (sideEmptyCount * 2)
        console.log(`${' '.repeat(sideEmptyCount)}${'*'.repeat(repeatTime)}${' '.repeat(sideEmptyCount)}`)
    }
}
// 验证
printDiamond(5)
//   *
//  ***
// *****
//  ***
//   *
``` 

## 小孩报数问题

```js
let arr = new Array(30).fill().map((_, index) => ({
    id: index,
    status: true,
    next: index + 1 >= 30 ? 0 : index + 1
}))
function roll() {
    let cur = 0
    let curItem = arr[0]
    while(arr.length > 1) {
        if (curItem.status) {
            cur++
            if (cur === 3) {
               curItem.status = false
               arr = arr.filter(item => item.status)
               cur = 0
            }
        }
        curItem = arr[curItem.next]
        console.log('...arr', arr)
    }
    console.log('...final', arr[0].id + 1)
    return arr[0].id + 1
}
roll()

```

## 手写 debounce

[JavaScript专题之跟着underscore学防抖](https://github.com/mqyqingfeng/Blog/issues/22)

```js
const debounce = (fn, ms = 0) => {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), ms);
  };
}

// 浏览器中执行
window.addEventListener(
  'resize',
  debounce(() => {
    console.log(window.innerWidth);
    console.log(window.innerHeight);
  }, 250)
); // Will log the window dimensions at most every 250ms
```

变形：

### （1）「setTimeout 里箭头函数改成 function 函数」行不行？

```js
const debounce = (fn, ms = 0) => {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(function() {
      fn.apply(this, args)
    }, ms);
  };
}

// 试验：
let person = {
  name: 'John',
  age: 23,
  getName: debounce(function() {
    console.log(this, this.name); // Timeout undefined
  }, 50)
}
person.getName();
```

这样行不行？答案不行，可以尝试下：

```js
```

这样 this 输出来是 Timeout 而不是 person `{ name: 'John', age: 23, getName: [Function (anonymous)] }`

因为 setTimeout 里如果不是箭头函数，this 是执行上下文 也就是 Timeout，否则箭头函数则是 function(...args) 上下文的 this

这种情况可以考虑在 setTimeout 外记录 this 为 context，再执行 apply：

```js
const debounce = (fn, ms = 0) => {
  let timeoutId;
  return function(...args) {
    let context = this;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(function() {
      fn.apply(context, args)
    }, ms);
  };
}
```

### （2）「fn.apply(context, args) 改成直接 fn(...args) 」行不行？

```js
const debounce = (fn, ms = 0) => {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(function() {
      fn(...args)
    }, ms);
  };
}

// 试验：
let person = {
  name: 'John',
  age: 23,
  getName: debounce(function() {
    console.log(this, this.name); // globalThis undefined
  }, 50)
}
person.getName();
```

同样不行，因为这样 fn 执行的时候，this 是函数的上下文对象即 globalThis，而不是调用者的上下文对象。

### 更完整的例子

```js
function debounce(fn, delay) {
  let timer = null;
  console.log('this1', this, this.name);
  return function() {
    let context = this;
    let args = arguments;
    console.log('this2',  this,this.name);
    clearTimeout(timer);
    timer = setTimeout(function() {
       console.log('this3', this, this.name);
       fn.apply(context, args);
    }, delay);
  }
}
// 试验：
let person = {
  name: 'John',
  age: 23,
  getName: debounce(function() {
    console.log(this, this.name); // Timeout undefined
  }, 50)
}
person.getName();
person.getName();
```

结果为：

```js
this1 globalThis undefined
this2 { name: 'John', age: 23, getName: [Function (anonymous)] } John
this2 { name: 'John', age: 23, getName: [Function (anonymous)] } John
this3 Timeout undefined // 可以看出，this3 也就是 setTimeout 里的 this，不同于外层的 this2
{ name: 'John', age: 23, getName: [Function (anonymous)] } John
```

### 引申 React 中的 this

```tsx
import { Component, createRef } from 'react'

const debounce = (fn, ms = 0) => {
  let timeoutId
  return function (...args) {
    let ctx = this
    clearTimeout(timeoutId)
    timeoutId = setTimeout(function () {
      // 执行 fn 函数
      // fn.apply(ctx, args)  // <button>click it.</button> click it.
      fn(...args) // undefined 报错
    }, ms)
  }
}

export default class App3 extends Component {
  state = {
    a: 1
  }
  btnRef = createRef()
  handleClick() {
    console.log(this)
    console.log(this.state)
  }
  componentDidMount() {
    if (this.btnRef.current) {
      this.btnRef.current.addEventListener(
        'onMouseMove',
        debounce(function () {
          console.log(this)
          console.log(this.innerHTML)
        }),
        1000
      )
    }
  }
  render() {
    return (
      <div>
        <button
          ref={this.btnRef}
          onClick={this.handleClick}
        >
          click it.
        </button>
      </div>
    )
  }
}
```

如上，点击按钮的时候，this.handleClick 执行，但是里面的 this 却是 undefined（严格模式），this.state 则报错。因此需要 `onClick={this.handleClick.bind(this)}`。

而在按钮上移动时，如果用 fn.apply(ctx, args) 则是 `<button>click it.</button> click it.`，而如果用 fn(...args) 则是 undefined 和报错。